#!/usr/bin/env python
#coding: UTF-8

import os
import re
import sys
import time
import struct
import socket
import select
import string
import tempfile
import telnetlib
import subprocess

TARGET = ('127.0.0.1', 4444)

#
# Helper functions
#
def e(d):
    return d.encode('UTF-8')

def d(d):
    return d.decode('UTF-8')

def p(d, fmt='<I'):
    return struct.pack(fmt, d)

def u(d, fmt='<I'):
    return struct.unpack(fmt, d)

def u1(d, fmt='<I'):
    return u(d, fmt)[0]

def contains_not(x, bad):
    return not any(c in bad for c in x)

def contains_only(x, good):
    return all(c in good for c in x)

def xor(s1, s2):
    return "".join([chr(ord(s1[i]) ^ ord(s2[i])) for i in range(len(s1))])

def validate(data, badchars):
    """Assert that no badchar occurs in data."""
    assert(all(b not in data for b in badchars))

def is_printable(b):
    """Return true if the given byte is a printable ASCII character."""
    return b in e(string.printable)

def tmpfile(pref="lalib-"):
    """Create and return a temporary file with custom prefix"""
    return tempfile.NamedTemporaryFile(prefix=pref)

def to_hexstr(str):
    """Convert a string to hex escape represent"""
    return "".join(["\\x%02x" % ord(i) for i in str])

def to_address(num):
    """Convert a number to address format in hex"""
    if num < 0:
        return to_hex(num)
    if num > 0xffffffff:  # 64 bit
        return "0x%016x" % num
    else:
        return "0x%08x" % num

def str2hex(str):
    """Convert a string to hex encoded format"""
    result = str.encode('hex')
    return result

def hex2str(hexnum):
    """Convert a number in hex format to string"""
    if not isinstance(hexnum, str):
        hexnum = to_hex(hexnum)
    s = hexnum[2:]
    if len(s) % 2 != 0:
        s = "0" + s
    result = s.decode('hex')[::-1]
    return result

def int2hexstr(num, intsize=4):
    """Convert a number to hexified string"""
    if intsize == 8:
        if num < 0:
            result = p(num, "<q")
        else:
            result = p(num, "<Q")
    else:
        if num < 0:
            result = p(num, "<l")
        else:
            result = p(num, "<L")
    return result

def list2hexstr(intlist, intsize=4):
    """Convert a list of number/string to hexified string"""
    result = ""
    for value in intlist:
        if isinstance(value, str):
            result += value
        else:
            result += int2hexstr(value, intsize)
    return result

def str2intlist(data, intsize=4):
    """Convert a string to list of int"""
    result = []
    data = data.decode('string_escape')[::-1]
    l = len(data)
    data = ("\x00" * (intsize - l % intsize) +
            data) if l % intsize != 0 else data
    for i in range(0, l, intsize):
        if intsize == 8:
            val = u1(data[i:i + intsize], ">Q")
        else:
            val = u1(data[i:i + intsize], ">L")
        result = [val] + result
    return result

def hex2ascii(h):
    """Convert hexadecimal to printable ascii
    Usage: print hex2ascii(0x6e69622f)"""
    chars_in_reverse = []
    while h != 0x0:
        chars_in_reverse.append(chr(h & 0xFF))
        h = h >> 8
    chars_in_reverse.reverse()
    return ''.join(chars_in_reverse)

def bitstr(n, width=None):
    """Return the binary representation of n as a string and optionally
    zero-fill (pad) it to a given length
    ex:
        >>> bitstr(123)
        >>> '1111011'
    """
    result = list()
    while n:
        result.append(str(n % 2))
        n = int(n / 2)
    if (width is not None) and len(result) < width:
        result.extend(['0'] * (width - len(result)))
    result.reverse()
    return ''.join(result)

def bash(cmd, cmd_input=None, timeout=None, return_stderr=False):
    """Execute cmd and return stdout and stderr in a tuple"""
    p = subprocess.Popen(['/bin/bash', '-c', cmd],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    if timeout is None:
        o, e = p.communicate(cmd_input)
    else:
        t = time.time()
        while time.time() - t < timeout:
            time.sleep(0.01)
            if p.poll() is not None:
                break
        if p.returncode is None:
            p.kill()
        o, e = p.communicate()
    if return_stderr:
        return o, e
    return o

def read(path):
    """Open file, return content."""
    path = os.path.expanduser(os.path.expandvars(path))
    with open(path) as fd:
        return fd.read()

def write(path, data, create_dir=False):
    """Create new file or truncate existing to zero length and write data."""
    path = os.path.expanduser(os.path.expandvars(path))
    if create_dir:
        path = os.path.realpath(path)
        ds = path.split('/')
        f = ds.pop()
        p = '/'
        while True:
            try:
                d = ds.pop(0)
            except:
                break
            p = os.path.join(p, d)
            if not os.path.exists(p):
                os.mkdir(p)
    with open(path, 'w') as f:
        f.write(data)

def hexdump( src, length=16, sep='.' ):
	"""Return {src} in hex dump.
	@param[in] length	{Int} Nb Bytes by row.
	@param[in] sep		{Char} For the text part, {sep} will be used for non ASCII char.
	@return {Str} The hexdump
	Note: Full support for python2 and python3 !
	"""
	result = [];
	try:
		xrange(0,1);
	except NameError:
		xrange = range;
	for i in xrange(0, len(src), length):
		subSrc = src[i:i+length];
		hexa = '';
		isMiddle = False;
		for h in xrange(0,len(subSrc)):
			if h == length/2:
				hexa += ' ';
			h = subSrc[h];
			if not isinstance(h, int):
				h = ord(h);
			h = hex(h).replace('0x','');
			if len(h) == 1:
				h = '0'+h;
			hexa += h+' ';
		hexa = hexa.strip(' ');
		text = '';
		for c in subSrc:
			if not isinstance(c, int):
				c = ord(c);
			if 0x20 <= c < 0x7F:
				text += chr(c);
			else:
				text += sep;
		result.append(('%08X:  %-'+str(length*(2+1)+1)+'s  |%s|') % (i, hexa, text));
	return '\n'.join(result);

def threaded(f, daemon=True):
    """Function decorator to use threading"""
    import threading
    import Queue
    def wrapped_f(q, *args, **kwargs):
        """this function calls the decorated function and puts the
        result in a queue"""
        ret = f(*args, **kwargs)
        q.put(ret)

    def wrap(*args, **kwargs):
        """this is the function returned from the decorator. It fires off
        wrapped_f in a new thread and returns the thread object with
        the result queue attached"""
        q = Queue.Queue()
        t = threading.Thread(target=wrapped_f, args=(q,)+args, kwargs=kwargs)
        t.setDaemon(daemon)
        t.setName(args[2])
        print "[+] Starting thread name %s daemon %s" % (t.name, t.isDaemon())
        t.start()
        t.result_queue = q
        return t
    return wrap

#
# Networking
#

# The default timeout (in seconds) to use for all operations that may raise an exception
DEFAULT_TIMEOUT = 5

# Custom exceptions raised by the Connection class
class ConnectionError(Exception):
    pass
class TimeoutError(ConnectionError):
    pass

class Connection:
    """Connection abstraction built on top of raw sockets."""
    def __init__(self, remote, local_port=0):
        self._socket = socket.create_connection(remote, DEFAULT_TIMEOUT, ('', local_port))

        # Disable kernel TCP buffering
        self._socket.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        self.disconnect()

    def disconnect(self):
        """Shut down and close the socket."""
        self._socket.shutdown(socket.SHUT_RDWR)
        self._socket.close()

    def recv(self, bufsize=4096, timeout=DEFAULT_TIMEOUT, dontraise=False):
        """Receive data from the remote end.
        If dontraise is True recv() will not raise a TimeoutError but instead return an empty string.
        """
        self._socket.settimeout(timeout)
        try:
            data = self._socket.recv(bufsize)
        except socket.timeout:
            if dontraise:
                return b''
            else:
                raise TimeoutError('timed out')
        # recv() returns an empty string if the remote end is closed
        if len(data) == 0:
            raise ConnectionError('remote end closed')
        return data

    def recvln(self, n=1, timeout=DEFAULT_TIMEOUT):
        """Receive lines from the remote end."""
        buf = b''
        while buf.count(b'\n') < n:
            # This maybe isn't great, but it's short and simple...
            buf += self.recv(1, timeout)
        return buf

    def recv_until_found(self, keywords, timeout=DEFAULT_TIMEOUT):
        """Receive incoming data until one of the provided keywords is found."""
        buf = b''
        while not any(True for kw in keywords if kw in buf):
            buf += self.recv(timeout=timeout)
        return buf

    def recv_until_match(self, regex, timeout=DEFAULT_TIMEOUT):
        """Receive incoming data until it matches the given regex."""
        if isinstance(regex, str):
            regex = re.compile(regex)
        buf = ''
        match = None
        while not match:
            buf += self.recv(timeout=timeout)
            match = regex.search(buf)
        return match

    def send(self, data):
        """Send all data to the remote end or raise an exception."""
        self._socket.sendall(data)

    def sendln(self, data):
        """Send all data to the remote end or raise an exception. Appends a \\n."""
        self.send(data + b'\n')

    def interact(self):
        """Interact with the remote end."""
        try:
            while True:
                sys.stdout.write(self.recv(timeout=.05, dontraise=True))
                available, _, _ = select.select([sys.stdin, self._socket], [], [], .05)
                if available:
                    data = sys.stdin.readline()
                    self.send(data)
        except KeyboardInterrupt:
            return

    def shell(self):
        """Pass to this function a socket with a listening shell(socket reuse)"""
        tc = telnetlib.Telnet()
        tc.sock = self._socket
        tc.interact()
        return

def connect(remote):
    """Factory function."""
    return Connection(remote)

#
# Exploit code below
#
if __name__ == "__main"":
	# Here the server is just "nc -k -v -e /bin/sh -l 0.0.0.0 4444"
	with connect(TARGET) as c:
		c.sendln("pwned")
		c.interact()
	# or, if you prefer no additional indention:
	# c = connect(TARGET)
	# c.interact()
	# c.disconnect()
